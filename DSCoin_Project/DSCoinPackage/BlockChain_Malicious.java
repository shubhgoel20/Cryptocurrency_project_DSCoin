package DSCoinPackage;

import HelperClasses.*;

public class BlockChain_Malicious {

  public int tr_count;
  public static final String start_string = "DSCoin";
  public TransactionBlock[] lastBlocksList = new TransactionBlock[100];

  public static boolean checkTransactionBlock (TransactionBlock tB) {
      CRF obj = new CRF(64);
      
      //checking of dgst.	
      if(!tB.dgst.substring(0,4).equals("0000")) return false;
      
      String dummy;
      String dummy2;
      if(tB.previous!=null) dummy = tB.previous.dgst;
      else dummy = start_string;
      dummy2 = obj.Fn(dummy + "#" + tB.trsummary + "#" + tB.nonce);
      if(!tB.dgst.equals(dummy2)) return false;
      
      MerkleTree temp = new MerkleTree();
      String dummy3 = temp.Build(tB.trarray);
      if(!dummy3.equals(tB.trsummary)) return false;
      
      //if tB is first block, then it will always be valid as it is generated by moderator.
      if(tB.previous == null) return true;
      
      for(int i = 0;i<tB.trarray.length;i++){
          if(!tB.previous.checkTransaction(tB.trarray[i])) return false;
      }
      
      return true;
  }

  public TransactionBlock FindLongestValidChain () {
      int maxlen = -1;
      TransactionBlock longB = this.lastBlocksList[0];
      if(longB == null) return longB;
      for(int i = 0;i<100;i++){
	  if(this.lastBlocksList[i] == null) break;
          TransactionBlock currB = this.lastBlocksList[i];
          TransactionBlock currlongB = this.lastBlocksList[i];
	  int currlen = 0;
          while(currB != null){
              if(checkTransactionBlock(currB)){
                  currlen++;
	      }
	      else{
                  currlen = 0;
                  currlongB = currB.previous;
              }
	      currB = currB.previous;
          }
	  if(currlen > maxlen){
              maxlen = currlen;
              longB = currlongB;
          }
      }
      return longB;
  }

  public void InsertBlock_Malicious (TransactionBlock newBlock) {
     CRF obj = new CRF(64);
     TransactionBlock lastBlock = this.FindLongestValidChain();
     int idx;
     for(idx = 0;idx<100;idx++){
         if(lastBlock == this.lastBlocksList[idx] || this.lastBlocksList[idx] == null){
	     break;
	 }
     }
     String dummy = new String();
     if(lastBlock == null) dummy = start_string;
     else dummy = lastBlock.dgst;
     for(long i = 1000000001L;i<=9999999999L;i++){
         String dummy2 = obj.Fn(dummy+"#"+newBlock.trsummary+"#"+Long.toString(i));
	 if(dummy2.substring(0,4).equals("0000")){
	     newBlock.dgst = dummy2;
	     newBlock.nonce = Long.toString(i);
	     break;
	 }
     }
     if(lastBlock == null){
	tr_count = newBlock.trarray.length;
	this.lastBlocksList[0] = newBlock;
     }
     else{	
     tr_count = newBlock.trarray.length;
     newBlock.previous =lastBlock;
     lastBlock.next = newBlock;
     this.lastBlocksList[idx] = newBlock;}
  }
}
